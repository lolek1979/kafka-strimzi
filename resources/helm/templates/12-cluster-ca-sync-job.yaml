{{- $nsK := include "kafka.ns" . -}}
{{- $nsUI := include "kafka-ui.ns" . -}}
{{- $nsSR := include "schema-registry.ns" . -}}
{{- $nsLag := include "lag-exporter.ns" . -}}
{{- $kui := .Values.kafkaUi | default (dict) -}}
{{- $kuiTls := (index $kui "tls") | default (dict) -}}
{{- $kuiCaSecret := default "" (index $kuiTls "caSecretName") -}}
{{- $kuiCaKey := default "ca.crt" (index $kuiTls "caCertificate") -}}
{{- $sr := .Values.schemaRegistry | default (dict) -}}
{{- $srTls := (index $sr "tls") | default (dict) -}}
{{- $srCaSecret := default "" (index $srTls "caSecretName") -}}
{{- $srCaKey := default "ca.crt" (index $srTls "caCertificate") -}}
{{- $lagExp := .Values.kafkaExporter | default (dict) -}}
{{- $lagTls := (index $lagExp "tls") | default (dict) -}}
{{- $lagCaSecret := default "" (index $lagTls "caSecretName") -}}
{{- $lagCaKey := default "ca.crt" (index $lagTls "caCertificate") -}}
{{- $loops := default 30 .Values.tls.sync.waitLoops -}}
{{- $sleep := default 2 .Values.tls.sync.waitSleepSeconds -}}
{{- $kafkaName := include "kafka.name" . -}}
{{- $waitReady := default 900 .Values.tls.sync.kafkaReadyTimeoutSeconds -}}
{{- if or $kuiCaSecret $srCaSecret $lagCaSecret }}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ printf "%s-ca-fanout" (default "akv-secrets-job" .Values.tls.sync.jobName) | quote }}
  namespace: {{ $nsK | quote }}
  annotations:
    "helm.sh/hook": "post-install,post-upgrade"
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": "before-hook-creation"
spec:
  backoffLimit: {{ default 0 .Values.tls.sync.backoffLimit }}
  ttlSecondsAfterFinished: 300
  template:
    spec:
      serviceAccountName: {{ default "tls-writer" .Values.tls.serviceAccount | quote }}
      restartPolicy: Never
      containers:
      - name: ca-fanout
        image: {{ default "alpine:3.20" .Values.tls.sync.image | quote }}
        command: ["/bin/sh","-c"]
        args:
          - |-
            set -euo pipefail
            apk add --no-cache coreutils kubectl >/dev/null

            wait_for_kafka_ready() {
              name="$1"
              timeout="$2"
              step="$3"
              [ -n "$name" ] || return 1
              remaining="$timeout"
              while [ "$remaining" -gt 0 ]; do
                status="$(kubectl -n {{ $nsK }} get kafka.kafka.strimzi.io "$name" -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || true)"
                if [ "$status" = "True" ]; then
                  return 0
                fi
                sleep "$step"
                remaining=$((remaining - step))
              done
              return 1
            }

            wait_for_secret() {
              name="$1"
              for i in $(seq 1 {{ $loops }}); do
                if kubectl -n {{ $nsK }} get secret "$name" >/dev/null 2>&1; then
                  return 0
                fi
                sleep {{ $sleep }}
              done
              return 1
            }

            KAFKA_NAME="{{ $kafkaName }}"
            WAIT_READY={{ $waitReady }}
            READY_STEP=10
            if [ "$WAIT_READY" -gt 0 ] && [ -n "$KAFKA_NAME" ]; then
              echo "[ca-fanout] Waiting for Kafka ${KAFKA_NAME} Ready (timeout: ${WAIT_READY}s)"
              if ! wait_for_kafka_ready "$KAFKA_NAME" "$WAIT_READY" "$READY_STEP"; then
                echo "[ca-fanout] WARN: Kafka ${KAFKA_NAME} not Ready after ${WAIT_READY}s; continuing with CA fan-out"
              fi
            fi

            copy_ca_secret() {
              dest_ns="$1"
              secret="$2"
              key="$3"
              [ -n "$secret" ] || return 0
              if ! wait_for_secret "$secret"; then
                echo "[ca-fanout] WARN: Timed out waiting for ${secret} in {{ $nsK }}"
                return 0
              fi
              path="{.data['$key']}"
              data="$(kubectl -n {{ $nsK }} get secret "$secret" -o jsonpath="$path" 2>/dev/null || true)"
              if [ -z "$data" ]; then
                alt="{.data.$(printf '%s' "$key" | sed 's/\./\\\./g')}"
                data="$(kubectl -n {{ $nsK }} get secret "$secret" -o jsonpath="$alt" 2>/dev/null || true)"
              fi
              if [ -z "$data" ]; then
                keys="$(kubectl -n {{ $nsK }} get secret "$secret" -o jsonpath='{range $k,$v := .data}{$k} {end}' 2>/dev/null || true)"
                echo "[ca-fanout] WARN: Secret ${secret} missing key ${key} in {{ $nsK }} (available: ${keys})"
                return 0
              fi
              tmp="$(mktemp)"
              if ! printf '%s' "$data" | base64 -d > "$tmp" 2>/dev/null; then
                echo "[ca-fanout] WARN: Failed to decode ${secret}/${key}"
                rm -f "$tmp"
                return 0
              fi
              kubectl -n "$dest_ns" create secret generic "$secret" \
                --from-file="${key}=$tmp" --dry-run=client -o yaml | kubectl apply -f -
              echo "[ca-fanout] Cluster CA ${secret} synced to ${dest_ns}"
              rm -f "$tmp"
            }

{{- if $kuiCaSecret }}
            copy_ca_secret {{ $nsUI | quote }} {{ $kuiCaSecret | quote }} {{ $kuiCaKey | quote }}
{{- end }}
{{- if $srCaSecret }}
            copy_ca_secret {{ $nsSR | quote }} {{ $srCaSecret | quote }} {{ $srCaKey | quote }}
{{- end }}
{{- if $lagCaSecret }}
            copy_ca_secret {{ $nsLag | quote }} {{ $lagCaSecret | quote }} {{ $lagCaKey | quote }}
{{- end }}
{{- end }}
