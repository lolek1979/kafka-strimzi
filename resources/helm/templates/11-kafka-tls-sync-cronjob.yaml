{{- if and .Values.azure.keyVaultName .Values.tls.materialize.enabled .Values.tls.sync.cron.enabled }}
{{- $nsK := include "kafka.ns" . -}}
{{- $nsUI := include "kafka-ui.ns" . -}}
{{- $nsSR := include "schema-registry.ns" . -}}
{{- $nsLag := include "lag-exporter.ns" . -}}
{{- $kui := .Values.kafkaUi | default (dict) -}}
{{- $kuiTls := (index $kui "tls") | default (dict) -}}
{{- $kuiCaSecret := default "" (index $kuiTls "caSecretName") -}}
{{- $kuiCaKey := default "ca.crt" (index $kuiTls "caCertificate") -}}
{{- $sr := .Values.schemaRegistry | default (dict) -}}
{{- $srTls := (index $sr "tls") | default (dict) -}}
{{- $srCaSecret := default "" (index $srTls "caSecretName") -}}
{{- $srCaKey := default "ca.crt" (index $srTls "caCertificate") -}}
{{- $lagExp := .Values.kafkaExporter | default (dict) -}}
{{- $lagTls := (index $lagExp "tls") | default (dict) -}}
{{- $lagCaSecret := default "" (index $lagTls "caSecretName") -}}
{{- $lagCaKey := default "ca.crt" (index $lagTls "caCertificate") -}}
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{ printf "%s-cron" (default "akv-secrets-materialize" .Values.tls.sync.jobName) }}
  namespace: {{ $nsK }}
spec:
  schedule: {{ .Values.tls.sync.cron.schedule | quote }}
  {{- with .Values.tls.sync.cron.timeZone }}
  timeZone: {{ . | quote }}
  {{- end }}
  successfulJobsHistoryLimit: {{ .Values.tls.sync.cron.successfulJobsHistoryLimit }}
  failedJobsHistoryLimit: {{ .Values.tls.sync.cron.failedJobsHistoryLimit }}
  suspend: {{ .Values.tls.sync.cron.suspend }}
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: {{ default "tls-writer" .Values.tls.serviceAccount }}
          restartPolicy: Never
          volumes:
          - name: akv
            csi:
              driver: secrets-store.csi.k8s.io
              readOnly: true
              volumeAttributes:
                secretProviderClass: {{ default "kafka-akv-secrets-spc" .Values.tls.spcName }}
          containers:
          - name: refresher
            image: {{ default "alpine:3.20" .Values.tls.sync.image }}
            command: ["/bin/sh","-c"]
            args:
            - |
              set -euo pipefail
              apk add --no-cache openssl coreutils kubectl
              ls -l /mnt/akv || true

              copy_ca_secret() {
                dest_ns="$1"
                secret="$2"
                key="$3"
                [ -n "$secret" ] || return 0
                if ! kubectl -n {{ $nsK }} get secret "$secret" >/dev/null 2>&1; then
                  echo "[cron] INFO: Source CA secret ${secret} not yet available in {{ $nsK }}; skipping ${dest_ns}"
                  return 0
                fi
                path="{.data['$key']}"
                data="$(kubectl -n {{ $nsK }} get secret "$secret" -o jsonpath="$path" 2>/dev/null || true)"
                if [ -z "$data" ]; then
                  alt="{.data.$(printf '%s' "$key" | sed 's/\./\\\./g')}"
                  data="$(kubectl -n {{ $nsK }} get secret "$secret" -o jsonpath="$alt" 2>/dev/null || true)"
                fi
                if [ -z "$data" ]; then
                  keys="$(kubectl -n {{ $nsK }} get secret "$secret" -o jsonpath='{range $k,$v := .data}{$k} {end}' 2>/dev/null || true)"
                  echo "[cron] WARN: Secret ${secret} missing key ${key} in {{ $nsK }} (available: ${keys})"
                  return 0
                fi
                tmp="$(mktemp)"
                if ! printf '%s' "$data" | base64 -d > "$tmp" 2>/dev/null; then
                  echo "[cron] WARN: Failed to decode CA key ${key} from ${secret}"
                  rm -f "$tmp"
                  return 0
                fi
                kubectl -n "$dest_ns" create secret generic "$secret" \
                  --from-file="${key}=$tmp" --dry-run=client -o yaml | kubectl apply -f -
                echo "[cron] Cluster CA ${secret} synced to ${dest_ns}"
                rm -f "$tmp"
              }

              if [ -s /mnt/akv/tls.crtkey.pem ]; then
                awk 'BEGIN{c=0} /BEGIN CERTIFICATE/{c=1} c{print} /END CERTIFICATE/{c=0}' /mnt/akv/tls.crtkey.pem > /tmp/tls.crt || true
                awk 'BEGIN{c=0} /BEGIN (ENCRYPTED )?PRIVATE KEY/{c=1} c{print} /END (ENCRYPTED )?PRIVATE KEY/{c=0}' /mnt/akv/tls.crtkey.pem > /tmp/tls.key || true
              fi

              CRT="/tmp/tls.crt"; KEY="/tmp/tls.key"
              [ -s "$CRT" ] || CRT="/mnt/akv/tls.crt"
              [ -s "$KEY" ] || KEY="/mnt/akv/tls.key"

              if [ -s "$CRT" ] && [ -s "$KEY" ]; then
                kubectl -n {{ $nsK }} create secret tls {{ .Values.tls.k8sSecretName }} \
                  --cert="$CRT" --key="$KEY" --dry-run=client -o yaml | kubectl apply -f -
                echo "[cron] TLS secret refreshed in {{ $nsK }}"
              else
                echo "[cron] WARN: TLS material not found; skipping"
              fi
{{- if $kuiCaSecret }}
              copy_ca_secret {{ $nsUI | quote }} {{ $kuiCaSecret | quote }} {{ $kuiCaKey | quote }}
{{- end }}
{{- if $srCaSecret }}
              copy_ca_secret {{ $nsSR | quote }} {{ $srCaSecret | quote }} {{ $srCaKey | quote }}
{{- end }}
{{- if $lagCaSecret }}
              copy_ca_secret {{ $nsLag | quote }} {{ $lagCaSecret | quote }} {{ $lagCaKey | quote }}
{{- end }}
            volumeMounts:
            - name: akv
              mountPath: /mnt/akv
              readOnly: true
{{- end }}
